import random
import math

# Print the board
def print_board(state):
    n = len(state)
    for i in range(n):
        row = ""
        for j in range(n):
            row += "Q " if state[j] == i else ". "
        print(row)
    print()

# Compute number of attacking pairs
def calculate_attacks(state):
    n = len(state)
    attacks = 0
    for i in range(n):
        for j in range(i + 1, n):
            if state[i] == state[j] or abs(state[i]-state[j]) == abs(i-j):
                attacks += 1
    return attacks

# Generate a random neighbor by moving one queen
def random_neighbor(state):
    n = len(state)
    neighbor = state[:]
    col = random.randint(0, n-1)
    new_row = random.randint(0, n-1)
    while new_row == neighbor[col]:
        new_row = random.randint(0, n-1)
    neighbor[col] = new_row
    return neighbor

# Simulated Annealing algorithm
def simulated_annealing(n=8, T=1000, cooling_rate=0.95, max_steps=10000):
    current_state = [random.randint(0, n-1) for _ in range(n)]
    current_h = calculate_attacks(current_state)

    step = 0
    while current_h > 0 and step < max_steps:
        neighbor = random_neighbor(current_state)
        neighbor_h = calculate_attacks(neighbor)
        delta_h = neighbor_h - current_h

        if delta_h < 0:
            current_state = neighbor
            current_h = neighbor_h
        else:
            prob = math.exp(-delta_h / T)
            if random.random() < prob:
                current_state = neighbor
                current_h = neighbor_h

        T *= cooling_rate
        step += 1

    print("Final board:")
    print_board(current_state)
    print("Final heuristic (attacking pairs):", current_h)
    if current_h == 0:
        print("âœ… Solution found!")
    else:
        print("âš ï¸ Could not find solution within max steps.")

# Run the 8-Queens problem
simulated_annealing()
